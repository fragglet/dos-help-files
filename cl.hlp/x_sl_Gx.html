<html>

<head>
<title>Quick-Data Memory Model: Details</title>
<link rel="stylesheet" href="../style.css">
</head>

<body>
<pre>
                                             <span class='grhilite'>◄</span><a href='x_sl_Gx.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/hv.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/vx.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
─────C/C++ Compiler─────────────────────────────────────────────────────────
 
     Syntax:  /Gx
 
     Under the the compact, large, or huge memory model, the compiler
     allocates initialized data items as near if they are smaller than
     or equal in size to the threshold value set by the /Gt option. The
     /Gx option extends this allocation rule for initialized data to
     data that is uninitialized and data that is marked as extern.
 
     Without the /Gx option, the compiler makes no assumptions about
     where the linker places uninitialized or extern data. All
     references to those data items are done with far addressing, in
     case they are placed in a far segment.
 
        ■ The compiler can generate more efficient code to reference
          data it knows is near.
 
        ■ You can achieve multiple instances of a single Windows
          application when all data is near.
 
     The /Gx option works only if the memory-model specification for
     each individual data declaration (and its definition) is consistent
     across compilation modules. That is, an individual data item is
     either __near everywhere, __far everywhere, or its memory model is
     not specified anywhere.
 
     Use the /Gx option with either the /AC, the /AL, or the /AH option
     to modify the compact, the large, or the huge memory model,
     respectively. With /Gx, all three memory models still offer
     multiple code and data segments.
 
     To ensure that all data is near, mark unsized arrays as __near,
     ensure that no data is marked as __far, and ensure that the data-
     size threshold set with the /Gt option does not force anything far.
     See: <span class='grhilite'>◄</span><a href='x_sl_Gt.html'>Data Size Threshold (/Gt)</a><span class='grhilite'>►</span>
          <span class='grhilite'>◄</span><a href='x_at_L8025.html'>Overriding Default Addressing</a><span class='grhilite'>►</span>
 
     Examples
 
          CL /AL /Gx ONE.C TWO.C
 
     This example compiles and links two modules, ONE.C and TWO.C,
     using the large memory model. Assume that ONE.C contains an
     external declaration of data (for example, extern struct strr;),
     and TWO.C defines struct strr as __near. In this case, specifying
     /Gx allows the compiler to safely generate more efficient code
     than would be possible if the compiler had to assume that struct
     strr might be far.
 
          CL /AL /Gx /Gt8 ONE.C TWO.C
 
     This example compiles and links two modules, ONE.C and TWO.C,
     using the large memory model. Because the /Gt option sets a data
     threshold size of eight bytes, the compiler assumes that all data
     items smaller than eight bytes and either uninitialized or marked
     as __extern are near.
 
     NOTE: If you reference a data item with near addressing but declare
           it with __far in another module, your program will produce
           unpredictable results.
                                    -♦-

</pre>
</body>

</html>
