<html>

<head>
<title>Large Memory Model: Details - C/C++ Compiler</title>
<link rel="stylesheet" href="../style.css">
<link rel="shortcut icon" href="/helpicon.png">
<link rel="icon" href="/helpicon.png">
</head>

<body>
<div class="page-heading">
<form action="https://www.google.com/search" method="GET">
<input name="as_q" id="search-box" placeholder="Search">
<input type="hidden" name="as_sitesearch" value="dos-help.soulsphere.org/*">
</form>
C/C++ Compiler (cl.hlp) (<a href='index.html'>Table of Contents</a>; <a href='TOPIC_LIST.html'>Topic list</a>)</div>
<div class="notice">
  <img src="../warning.png">
  <div class="heading">
    Important Notice
  </div>
  <div class="text">
    The pages on this site contain documentation for very old MS-DOS software,
    purely for historical purposes.

    If you're looking for up-to-date documentation, particularly for programming,
    you should not rely on the information found here, as it will be woefully
    out of date.
  </div>
</div>
<div class="page-title"> Large Memory Model: Details</div>
<pre>                                             <span class='grhilite'>◄</span><a href='x_at_L801c.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/hv.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/vx.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
─────C/C++ Compiler─────────────────────────────────────────────────────────
 
     Syntax:  /AL
 
     The large-model option allows multiple segments for both code and
     data, as needed. No individual data item can exceed 64K.
 
     This memory model is useful for large programs that require a
     large amount of data storage.
 
     The defaults in large-model programs are far code addressing and
     far data addressing. You can override the defaults with the __near
     keyword for code and the __near or __huge keyword for data.
 
     To maximize efficiency, the compiler tries to allocate static and
     initialized global data in DGROUP. The compiler allocates data
     items larger in size than the data-size threshold (set with /Gt) in
     segments outside of DGROUP. The sum of all the items smaller than
     the threshold must be less than 64K.
     See: <span class='grhilite'>◄</span><a href='x_sl_Gt.html'>Data Size Threshold (/Gt)</a><span class='grhilite'>►</span>
 
     Under the compact, large, or huge memory model, the compiler
     allocates initialized data items as near if they are smaller than
     or equal in size to the threshold value set by the /Gt option. The
     /Gx option extends this initialized data allocation rule to data
     that is uninitialized and data that is marked as extern. Near
     data offers two benefits:
 
        ■ The compiler can generate more efficient code to reference
          data it knows is near.
 
        ■ You can achieve multiple instances of a single windows
          application when all data is near.
 
     See: <span class='grhilite'>◄</span><a href='x_at_L8025.html'>Overriding Default Addressing</a><span class='grhilite'>►</span>
          <span class='grhilite'>◄</span><a href='x_sl_Gx.html'>Assume That Data Is Near Option (/Gx)</a><span class='grhilite'>►</span>
 
     Using the /AL option causes CL to emit both the _M_I86 and the
     _M_I86LM preprocessor identifiers.
                                    -♦-
</pre>
</body>

</html>
