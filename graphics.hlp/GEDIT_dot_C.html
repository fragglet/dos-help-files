<html>

<head>
<title>GEDIT.C - graphics.hlp</title>
<link rel="stylesheet" href="../style.css">
<link rel="shortcut icon" href="../helpicon.png">
</head>

<body>
<div class="page-heading">
<form action="https://www.google.com/search" method="GET">
<input name="as_q" id="search-box" placeholder="Search">
<input type="hidden" name="as_sitesearch" value="fragglet.github.io/dos-help-files/*">
</form>
graphics.hlp (<a href='TOPIC_LIST.html'>Topic list</a>)</div>
<div class="notice">
  <img src="../warning.png">
  <div class="heading">
    Important Notice
  </div>
  <div class="text">
    The pages on this site contain documentation for very old MS-DOS software,
    purely for historical purposes.

    If you're looking for up-to-date documentation, particularly for programming,
    you should not rely on the information found here, as it will be woefully
    out of date.
  </div>
</div>
<div class="page-title"> GEDIT.C</div>
<pre>                                             <span class='grhilite'>◄</span><a href='../qc.hlp/examples_dot_lst.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../qc.hlp/qc_dot_contents.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../qc.hlp/qc_dot_index.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
────────────────────────────────────────────────────────────────────────────
 
/* GEDIT.C illustrates translation between window, view, and
 * physical coordinates. Functions used include:
 *      _getwindowcoord     _getviewcoord_wxy       _getphyscoord
 *      _getcolor           _getcurrentposition_w   _getpixel_w
 *      _setcolor           _setwindow              _setpixel_w
 *      _lineto_w           _moveto_w
 *
 * Similar functions not used in the example include:
 *      _getviewcoord_w     _getcurrentposition     _getpixel
 *
 * See <a href='WINDOW_dot_C.html'>WINDOW.C</a> for another example of _setwindow.
 */
 
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;graph.h&gt;
 
/* Enums set constants to 0, 1, 2, etc. */
enum BOOL { FALSE, TRUE };
enum DISPLAY { MOVE, DRAW, ERASE };
 
void main()
{
    struct xycoord view, phys;
    struct _wxycoord oldwin, newwin;
    struct videoconfig vc;
    double xunit, yunit, xinc, yinc;
    int key, fintersect =FALSE, fdisplay = TRUE;
    short color;
 
    if( !_setvideomode( _MAXRESMODE ) ) /* Find a valid graphics mode  */
        exit( 1 );                      /* No graphics available       */
    _getvideoconfig( &amp;vc );
 
    /* Set a window using real numbers. */
    _setwindow( FALSE, -125.0, -100.0, 125.0, 100.0 );
 
    /* Calculate the size of one pixel in window coordinates. Then get
     * the current window coordinates and color.
     */
    oldwin = _getwindowcoord( 1, 1 );
    newwin = _getwindowcoord( 2, 2 );
    xunit = xinc = newwin.wx - oldwin.wx;
    yunit = yinc = newwin.wy - oldwin.wy;
    newwin = oldwin = _getcurrentposition_w();
    color = _getcolor();
 
    while( 1 )
    {
        /* Set flag according to whether current pixel is on, then
         * turn pixel on.
         */
        if( _getpixel_w( oldwin.wx, oldwin.wy ) == color )
            fintersect = TRUE;
        else
            fintersect = FALSE;
        _setcolor( color );
        _setpixel_w( oldwin.wx, oldwin.wy );
 
        /* Get and test key. */
        key = getch();
        switch( key )
        {
            case 27:                        /* ESC Quit                 */
                exit( !_setvideomode( _DEFAULTMODE ) );
            case 45:                        /* MINUS More granularity   */
                if( xinc &gt; xunit )
                {
                    yinc -= yunit;
                    xinc -= xunit;
                }
                continue;
            case 43:                        /* PLUS Less granularity    */
                yinc += yunit;
                xinc += xunit;
                continue;
            case 32:                        /* SPACE    Move no color   */
                fdisplay = MOVE;
                continue;
            case 0:                         /* Extended code - get next */
                key = getch();
                switch( key )
                {
                    case 71:                /* HOME     -x -y           */
                        newwin.wx -= xinc;  /*   (note fall through)    */
                    case 72:                /* UP          -y           */
                        newwin.wy -= yinc;
                        break;
                    case 73:                /* PGUP     +x -y           */
                        newwin.wy -= yinc;
                    case 77:                /* RIGHT    +x              */
                        newwin.wx += xinc;
                        break;
                    case 81:                /* PGDN     +x +y           */
                        newwin.wx += xinc;
                    case 80:                /* DOWN        +y           */
                        newwin.wy += yinc;
                        break;
                    case 79:                /* END      -x +y           */
                        newwin.wy += yinc;
                    case 75:                /* LEFT     -x              */
                        newwin.wx -= xinc;
                        break;
                    case 82:                /* INS      Draw white      */
                        fdisplay = DRAW;
                        continue;
                    case 83:                /* DEL      Draw black      */
                        fdisplay = ERASE;
                        continue;
                }
                break;
        }
 
        /* Translate window coordinates to view, view to physical. Then
         * check physical to make sure we're on screen. Update screen and
         * position if we are. Ignore if not.
         */
        view = _getviewcoord_wxy( &amp;newwin );
        phys = _getphyscoord( view.xcoord, view.ycoord );
        if( (phys.xcoord &gt;= 0) &amp;&amp; (phys.xcoord &lt; vc.numxpixels) &amp;&amp;
            (phys.ycoord &gt;= 0) &amp;&amp; (phys.ycoord &lt; vc.numypixels) )
        {
            /* If display on, draw to new position, else move to new. */
            if( fdisplay )
            {
                if( fdisplay == ERASE )
                    _setcolor( 0 );
                _lineto_w( newwin.wx, newwin.wy );
            }
            else
            {
                _setcolor( 0 );
                _moveto_w( newwin.wx, newwin.wy );
 
                /* If there was no intersect, erase old pixel. */
                if( !fintersect )
                    _setpixel_w( oldwin.wx, oldwin.wy );
            }
            oldwin = newwin;
        }
        else
            newwin = oldwin;
    }
}
</pre>
</body>

</html>
