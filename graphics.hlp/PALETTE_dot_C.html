<html>

<head>
<title>PALETTE.C - graphics.hlp</title>
<link rel="stylesheet" href="../style.css">
<link rel="shortcut icon" href="../helpicon.png">
</head>

<body>
<div class="page-heading">
<form action="https://duckduckgo.com/" method="GET">
<input name="q" id="search-box" placeholder="Search">
<input type="hidden" name="sites" value="fragglet.github.io">
</form>
graphics.hlp (<a href='TOPIC_LIST.html'>Topic list</a>)</div>
<div class="page-title"> PALETTE.C</div>
<pre>                                             <span class='grhilite'>◄</span><a href='../qc.hlp/examples_dot_lst.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../qc.hlp/qc_dot_contents.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../qc.hlp/qc_dot_index.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
────────────────────────────────────────────────────────────────────────────
 
/* PALETTE.C illustrates functions for assigning color values to
 * color indexes. Functions illustrated include:
 *      _remappalette       _remapallpalette
 */
 
#include &lt;graph.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
/* Macro for mixing Red, Green, and Blue elements of color */
#define RGB(r,g,b) (((long) ((b) &lt;&lt; 8 | (g)) &lt;&lt; 8) | (r))
 
long tmp, pal[256];
void main()
{
    short red, blue, green;
    short inc, i, mode, cells, x, y, xinc, yinc;
    char buf[40];
    struct videoconfig vc;
 
    /* Make sure all palette numbers are valid. */
    for( i = 0; i &lt; 256; i++ )
        pal[i] = _BLACK;
 
    /* Loop through each graphics mode that supports palettes. */
    for( mode = _MRES4COLOR; mode &lt;= _MRES256COLOR; mode++ )
    {
        if( mode == _ERESNOCOLOR )
            mode++;
        if( !_setvideomode( mode ) )
            continue;
 
        /* Set variables for each mode. */
        _getvideoconfig( &amp;vc );
        switch( vc.numcolors )
        {
            case 256:           /* Active bits in this order:           */
                cells = 13;
                inc = 12;       /* ???????? ??bbbbbb ??gggggg ??rrrrrr  */
                break;
            case  16:
                cells = 4;
                if( (vc.mode == _ERESCOLOR) || (vc.mode == _VRES16COLOR) )
                    inc = 16;   /* ???????? ??bb???? ??gg???? ??rr????  */
                else
                    inc = 32;   /* ???????? ??Bb???? ??Gg???? ??Rr????  */
                break;
            case   4:
                cells = 2;
                inc = 32;       /* ???????? ??Bb???? ??Gg???? ??Rr????  */
                break;
            default:
                continue;
        }
        xinc = vc.numxpixels / cells;
        yinc = vc.numypixels / cells;
 
        /* Fill palette arrays in BGR order. */
        for( i = 0, blue = 0; blue &lt; 64; blue += inc )
            for( green = 0; green &lt; 64; green += inc )
                for( red = 0; red &lt; 64; red += inc )
                {
                    pal[i] = RGB( red, green, blue );
                    /* Special case of using 6 bits to represent 16 colors.
                     * If both bits are on for any color, intensity is set.
                     * If one bit is set for a color, the color is on.
                     */
                    if( inc == 32 )
                        pal[i + 8] = pal[i] | (pal[i] &gt;&gt; 1);
                    i++;
                }
 
        /* If palettes available, remap all palettes at once. */
        if( !_remapallpalette( pal ) )
        {
            _setvideomode( _DEFAULTMODE );
            _outtext( "Palettes not available with this adapter" );
            exit( 1 );
        }
 
        /* Draw colored squares. */
        for( i = 0, x = 0; x &lt; ( xinc * cells ); x += xinc )
            for( y = 0; y &lt; ( yinc * cells); y += yinc )
            {
                _setcolor( i++ );
                _rectangle( _GFILLINTERIOR, x, y, x + xinc, y + yinc );
            }
 
        /* For 256-color mode, not all colors are shown. The number of
         * colors from mixing three base colors will never be the same
         * as the number that can be shown on a two-dimensional grid.
         */
        sprintf( buf, "Mode %d has %d colors", vc.mode, vc.numcolors );
        _setcolor( vc.numcolors / 2 );
        _outtext( buf );
        getch();
 
        /* Change each palette entry separately in GRB order. */
        for( i = 0, green = 0; green &lt; 64; green += inc )
            for( red = 0; red &lt; 64; red += inc )
                for(blue = 0; blue &lt; 64; blue += inc )
                {
                    tmp = RGB( red, green, blue );
                    _remappalette( i, tmp );
                    if( inc == 32 )
                        _remappalette( i + 8, tmp | (tmp &gt;&gt; 1) );
                    i++;
                }
        getch();
    }
    _setvideomode( _DEFAULTMODE );
}
</pre>
</body>

</html>
