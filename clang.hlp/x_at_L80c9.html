<html>

<head>
<title>HARDERR.C</title>
<link rel="stylesheet" href="../style.css">
</head>

<body>
<pre>
                                             <span class='grhilite'>◄</span><a href='x_at_L8122.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/hv.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='../advisor.hlp/vx.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
─────Run-Time Library───────────────────────────────────────────────────────
 
/* HARDERR.C illustrates handling of hardware errors using functions:
 *      _harderr            _hardresume         _hardretn         (DOS-only)
 */
 
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;
#include &lt;bios.h&gt;
 
void __far hhandler( unsigned deverr, unsigned doserr, unsigned __far *hdr );
int _bios_str( char *p );
 
void main()
{
    /* Install our hard error handler. */
    _harderr( hhandler );
 
    /* Test it. */
    printf( "Make sure there is no disk in drive A:\n" );
    printf( "Press a key when ready...\n" );
    _getch();
    if( _mkdir( "a:\\test" ) )
    {
        printf( "Failed" );
        exit( 1 );
    }
    else
    {
        printf( "Succeeded" );
        _rmdir( "a:test" );
        exit( 0 );
    }
}
 
/* Handler to deal with hard error codes. Since DOS is not reentrant,
 * it is not safe to use DOS calls for doing I/O within the DOS Critical
 * Error Handler (int 24h) used by _harderr. Therefore, screen output and
 * keyboard input must be done through the BIOS.
 */
void __far hhandler( unsigned deverr, unsigned doserr, unsigned __far *hdr )
{
    int ch;
    static char buf[200], tmpbuf[10];
 
    /* Copy message to buffer, then use BIOS to print it. */
    strcpy( buf, "\n\rDevice error code: " );
    strcat( buf, _itoa( deverr, tmpbuf, 10 ) );
    strcat( buf, "\n\rDOS error code:    " );
    strcat( buf, _itoa( doserr, tmpbuf, 10 ) );
    strcat( buf, "\n\r(R)etry, (F)ail, or (Q)uit? " );
 
    /* Use BIOS to write strings and get a key. */
    _bios_str( buf );
    ch = _bios_keybrd( _KEYBRD_READ ) &amp; 0x00ff;
    _bios_str( "\n\r" );
 
    switch( ch )
    {
        case 'R':
        case 'r':       /* Try again */
        default:
            _hardresume( _HARDERR_RETRY );
        case 'Q':
        case 'q':       /* Quit program */
 
            /* The following statement may fail in the PWB environment
             * because of conflicts with PWB's hard error handler. The
             * Quit selection falls through to the Fail selection. You
             * can remove the comment to enable this line if you wish to
             * test from the command line.
            _hardresume( _HARDERR_ABORT );
             */
        case 'F':
        case 'f':       /* Return to DOS with error code */
            _hardretn( doserr );
 
    }
}
 
/* Display a string using BIOS interrupt 0x0e (Write TTY). Return length
 * of string displayed.
 */
int _bios_str( char *p )
{
    union _REGS inregs, outregs;
    char *start = p;
 
    inregs.h.ah = 0x0e;
    for( ; *p; p++ )
    {
        inregs.h.al = *p;
        _int86( 0x10, &amp;inregs, &amp;outregs );
    }
    return p - start;
}
                                    -♦-

</pre>
</body>

</html>
