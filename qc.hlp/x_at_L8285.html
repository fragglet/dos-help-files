<html>

<head>
<title>COPY1.C</title>
<link rel="stylesheet" href="../style.css">
</head>

<body>
<form action="https://duckduckgo.com/" method="GET">
<input name="q" id="search-box" placeholder="Search">
<input type="hidden" name="sites" value="fragglet.github.io">
</form>
<div class="page-title"> COPY1.C</div>
<pre>                                             <span class='grhilite'>◄</span><a href='lib_dot_lst.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='index.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='h_dot_index.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
────────────────────────────────────────────────────────────────────────────
 
/* COPY1.C illustrates low-level file I/O and dynamic memory allocation
 * functions including:
 *      open            close
 *      read            write           eof
 *      malloc          free            _memmax
 *
 * Also the global variable:
 *      errno
 *
 * See <a href='x_at_L8286.html'>COPY2.C</a> for another version of the copyfile function and
 * <a href='x_at_L8299.html'>HEAPBASE.C</a> for an example of based heap management.
 */
 
#include &lt;io.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;          /* O_ constant definitions */
#include &lt;sys\types.h&gt;
#include &lt;sys\stat.h&gt;       /* S_ constant definitions */
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;
 
int copyfile( char *source, char *destin );     /* Prototype */
 
void main( int argc, char *argv[] )
{
    if( argc == 3 )
        if( copyfile( argv[1], argv[2] ) )
            printf( "Copy failed\n" );
        else
            printf( "Copy successful\n" );
    else
        printf( "  SYNTAX: COPY1 &lt;source&gt; &lt;target&gt;\n" );
}
 
/* Copies one file to another (both specified by path). Dynamically
 * allocates memory for the file buffer. Prompts before overwriting
 * existing file. Returns 0 if successful, otherwise an error number.
 */
int copyfile( char *source, char *target )
{
    char *buf;
    int hsource, htarget, ch;
    unsigned count = 0xff00;
 
    /* Open source file and create target, overwriting if necessary. */
    if( (hsource = open( source, O_BINARY | O_RDONLY )) == - 1 )
        return errno;
    htarget = open( target, O_BINARY | O_WRONLY | O_CREAT | O_EXCL,
                            S_IREAD | S_IWRITE );
    if( errno == EEXIST )
    {
        cputs( "Target exists. Overwrite? " );
        ch = getch();
        if( (ch == 'y') || (ch == 'Y') )
            htarget = open( target, O_BINARY | O_WRONLY | O_CREAT | O_TRUNC,
                                    S_IREAD | S_IWRITE );
        printf( "\n" );
    }
    if( htarget == -1 )
        return errno;
 
    if( filelength( hsource ) &lt; count )
        count = (int)filelength( hsource );
 
    /* Dynamically allocate a large file buffer. If there's not enough
     * memory for it, find the largest amount available on the near heap
     * and allocate that. This can't fail, no matter what the memory model.
     */
    if( (buf = (char *)malloc( (size_t)count )) == NULL )
    {
        count = _memmax();
        if( (buf = (char *)malloc( (size_t)count )) == NULL )
            return ENOMEM;
    }
 
    /* Read-write until there's nothing left. */
    while( !eof( hsource ) )
    {
        /* Read and write input. */
        if( (count = read( hsource, buf, count )) == -1 )
            return errno;
        if( (count = write( htarget, buf, count )) == - 1 )
            return errno;
    }
 
    /* Close files and release memory. */
    close( hsource );
    close( htarget );
    free( buf );
    return 0;
}
</pre>
</body>

</html>
