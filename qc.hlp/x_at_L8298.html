<html>

<head>
<title>HARDERR.C - qc.hlp</title>
<link rel="stylesheet" href="../style.css">
<link rel="shortcut icon" href="../helpicon.png">
</head>

<body>
<div class="page-heading">
<form action="https://duckduckgo.com/" method="GET">
<input name="q" id="search-box" placeholder="Search">
<input type="hidden" name="sites" value="fragglet.github.io">
</form>
qc.hlp (<a href='index.html'>Table of Contents</a>; <a href='TOPIC_LIST.html'>Topic list</a>)</div>
<div class="page-title"> HARDERR.C</div>
<pre>                                             <span class='grhilite'>◄</span><a href='lib_dot_lst.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='index.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='h_dot_index.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
────────────────────────────────────────────────────────────────────────────
 
/* HARDERR.C illustrates handling of hardware errors using functions:
 *      _harderr            _hardresume         _hardretn
 */
 
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;
#include &lt;bios.h&gt;
 
void _far hhandler( unsigned deverr, unsigned doserr, unsigned _far *hdr );
int _bios_str( char *p );
 
void main()
{
    /* Install our hard error handler. */
    _harderr( hhandler );
 
    /* Test it. */
    printf( "Make sure there is no disk in drive A:\n" );
    printf( "Press a key when ready...\n" );
    getch();
    if( mkdir( "a:\test" ) )
    {
        printf( "Failed" );
        exit( 1 );
    }
    else
    {
        printf( "Succeeded" );
        rmdir( "a:test" );
        exit( 0 );
    }
}
 
/* Handler to deal with hard error codes. Since DOS is not reentrant,
 * it is not safe to use DOS calls for doing I/O within the DOS Critical
 * Error Handler (int 24h) used by _harderr. Therefore, screen output and
 * keyboard input must be done through the BIOS.
 */
void _far hhandler( unsigned deverr, unsigned doserr, unsigned _far *hdr )
{
    int ch;
    static char buf[200], tmpbuf[10];
 
    /* Copy message to buffer, then use BIOS to print it. */
    strcpy( buf, "\n\rDevice error code: " );
    strcat( buf, itoa( deverr, tmpbuf, 10 ) );
    strcat( buf, "\n\rDOS error code:    " );
    strcat( buf, itoa( doserr, tmpbuf, 10 ) );
    strcat( buf, "\n\r(R)etry, (F)ail, or (Q)uit? " );
 
    /* Use BIOS to write strings and get a key. */
    _bios_str( buf );
    ch = _bios_keybrd( _KEYBRD_READ ) &amp; 0x00ff;
    _bios_str( "\n\r" );
 
    switch( ch )
    {
        case 'R':
        case 'r':       /* Try again */
        default:
            _hardresume( _HARDERR_RETRY );
        case 'Q':
        case 'q':       /* Quit program */
 
            /* The following statement may fail in the PWB environment
             * because of conflicts with PWB's hard error handler. The
             * Quit selection falls through to the Fail selection. You
             * can remove the comment to enable this line if you wish to
             * test from the command line.
            _hardresume( _HARDERR_ABORT );
             */
        case 'F':
        case 'f':       /* Return to DOS with error code */
            _hardretn( doserr );
 
    }
}
 
/* Display a string using BIOS interrupt 0x0e (Write TTY). Return length
 * of string displayed.
 */
int _bios_str( char *p )
{
    union REGS inregs, outregs;
    char *start = p;
 
    inregs.h.ah = 0x0e;
    for( ; *p; p++ )
    {
        inregs.h.al = *p;
        int86( 0x10, &amp;inregs, &amp;outregs );
    }
    return p - start;
}
</pre>
</body>

</html>
