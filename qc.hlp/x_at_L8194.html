<html>

<head>
<title>_chain_intr - qc.hlp</title>
<link rel="stylesheet" href="../style.css">
<link rel="shortcut icon" href="../helpicon.png">
</head>

<body>
<div class="page-heading">
<form action="https://www.google.com/search" method="GET">
<input name="as_q" id="search-box" placeholder="Search">
<input type="hidden" name="as_sitesearch" value="fragglet.github.io/dos-help-files/*">
</form>
qc.hlp (<a href='index.html'>Table of Contents</a>; <a href='TOPIC_LIST.html'>Topic list</a>)</div>
<div class="page-title"> _chain_intr</div>
<pre> <span class='grhilite'>◄</span><a href='x_chain_intr.html'>Summary</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='x_at_L8276.html'>Example</a><span class='grhilite'>►</span>                         <span class='grhilite'>◄</span><a href='lib_dot_lst.html'>Up</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='index.html'>Contents</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='h_dot_index.html'>Index</a><span class='grhilite'>►</span> <span class='grhilite'>◄</span><a href='javascript:history.back();'>Back</a><span class='grhilite'>►</span>
────────────────────────────────────────────────────────────────────────────
 
     The _chain_intr routine passes control from one interrupt handler
     to another. The stack and the registers of the first routine are
     passed to the second, allowing the second routine to return as if
     it had been called directly.
 
     The _chain_intr routine is generally used when a user-defined
     interrupt handler begins processing, then chains to the original
     interrupt handler to finish processing.
 
     Chaining is one of two techniques, listed below, that can be used
     to transfer control from a new interrupt routine to an old one:
 
       1. Call _chain_intr with the interrupt routine as an argument.
          Do this if your routine is finished and you want the second
          interrupt routine to terminate the interrupt call.
 
               void _interrupt _cdecl new_int( unsigned _es,
                                               unsigned _ds,
                                               unsigned _di,
                                               unsigned _si,... )
               {
               ++_di;                     // Initial processing here
               _chain_intr( old_int );    // New DI passed to old_int
               --_di;                     // This is never executed
               }
 
       2. Call the interrupt routine (after casting it to an interrupt
          function if necessary) if you need to do further processing
          after the second interrupt routine finishes.
 
               void _interrupt _cdecl new_int( unsigned _es,
                                               unsigned _ds,
                                               unsigned _di,
                                               unsigned _si,... )
               {
 
                  ++_di;                  // Initial processing here
                  (*old_int)();           // New DI passed to old_int
                  _asm mov _di, di        // Put real DI from old_int
                                          //   into _di for return
               }
 
          Note that the real registers set by the old _interrupt
          function are not automatically set to the pseudoregisters of
          the new routine.
 
     Use the _chain_intr function when you do not want to replace the
     default interrupt handler, but you do need to see its input. An
     example is a TSR (terminate-and-stay-resident) program that checks
     all keyboard input for a particular "hot key" sequence.
 
     The _chain_intr function should be used only with C functions that
     have been declared with type _interrupt. The _interrupt
     declaration ensures that the procedure's entry/exit sequence is
     appropriate for an interrupt handler.
 
     Return Value
 
     None.
                                    -♦-
</pre>
</body>

</html>
